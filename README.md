# Hibernate

https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html

Статьи для дополнения:
https://habr.com/ru/post/542328/
https://habr.com/ru/post/249073/
https://habr.com/ru/post/132385/
https://habr.com/ru/post/416851/

**ORM** — (англ. Object-relational mapping). В двух словах ORM — это отображение объектов какого-либо объектно-ориентированного языка в структуры реляционных баз данных.

**Hibernate** - это инструмент ORM на основе Java, который обеспечивает структуру для сопоставления POJO с таблицами реляционной базы данных и наоборот.

**JPA** - это спецификация для управления реляционными данными в приложениях.

### Аннотации
- **@Entity** - указывает что класс является сущностью.
- **@Table** - указывает таблицу в базе данных с которой сопоставлен этот объект.
- **@Column** - аннотация используется для указания сопоставления между базовым атрибутом объектом и столбцом таблицы базы данных.
- **@Id** - первичный ключ объекта.
- **@GeneratedValue** - эта аннотация определяет стратегии генерации первичнх ключей.
- **@OneToMany** и **@ManyToOne** - отображают связь один-ко-многим и многие-к-одному.
    - fetch в @OneToMany обозначает, когда загружать дочерние объекты.
        - FetchType.EAGER - загружать коллекцию дочерних объектов сразу же, при загрузке родительских объектов.
        - FetchType.LAZY - загружать коллекцию дочерних объектов при первом обращении к ней (вызове get) — так называемая отложенная загрузка.
    - cascade обозначает какие из методов интерфейса Session будут распространяться каскадно с ассоциированными сущностями.

### Архитектура
    
Hibernate, как ORM-решение, эффективно «находится между» уровнем доступа к данным Java-приложения и реляционной базой данных. Приложение Java использует API-интерфейсы Hibernate для загрузки, хранения, запроса и т.д.
  + **SessionFactory(org.hibernate.SessionFactory)**
    
    Поточно-ориентированное (и неизменяемое) представление сопоставления модели домена приложения с базой данных. Действует как фабрика для экземпляров org.hibernate.Session . EntityManagerFactory является JPA эквивалентом SessionFactory и в основном, те две сходятся в одном SessionFactory реализации.
    
  + **Session(org.hibernate.Session)**
    
    Однопоточный, недолговечный объект, концептуально моделирующий «единицу работы». Hibernate является оболочкой для java.sql.Connection и действует как фабрика для экземпляров org.hibernate.Transaction.
    
  + **Transaction(org.hibernate.Transaction)**

    Однопоточный краткосрочный объект используется приложением для определения границ отдельных физических транзакций. Действует, как API абстракции, чтобы изолировать приложение от используемой базовой системы транзакций (JDBC или JTA).
    
В Hibernate работа с БД осуществляется через объект типа Session. Интерфейс Session является мостом между приложением и Hibernate. С помощью сессий выполняются все CRUD-операции с объектами-сущеностями. Объект типа session получают из экземпляра типа SessionFactory.

#### Состояния объектов

Объект-сущность может находиться в одном из 3-х состояний (статусов):
- **transient object(переходный)** . Объект является временным , если он только что был создан с помощью оператора new и не связан с сеансом Hibernate. Не имеет постоянного представления в базе данных и нет Id. Объекты в данном статусе — это заполненные экземпляры классов-сущностей. Могут быть сохранены в БД(стать постоянным). Поле Id не должно быть заполнено, иначе объект имеет статус detached;
- **persistent object(постоянный)** . Объект в данном статусе — так называемая хранимая сущность, которая присоединена к конкретной сессии. Имеет представление в базе данных и Id. Только в этом статусе объект взаимодействует с базой данных. При работе с объектом данного типа в рамках транзакции все изменения объекта записываются в базу;
- **detached object(отсоединенный)** . Отсоединенный экземпляр - это объект, который был постоянным, но его сеанс был закрыт. Может существовать или не существовать в БД. 

Объект проходит состояния в следующем порядке: Transient -> Persistent -> Detached

Объект находится в состоянии Transient после его создания и до момента сохранения. После сохранения объекта(либо при чтении ранее сохраненного объекта из БД) он находится в состоянии Persistent пока не закрыта сессия. После закрытия сессии объект становится Detached.


#### Основные методы Session

- **persistent(Object)** - преобразует объект из transient в persistent. То есть присоединяет к сессии и сохраняет в БД.
- **merge(Object)** - преобразует объект из transient или detached в persistent. Если из transient, то работает аналогично persist() (генерирует для объекта новый Id, даже если он задан), если из detached — загружает объект из БД, присоединяет к сессии, а при сохранении выполняет запрос update.
- **replicate(Object, ReplicationMode)** - преобразует объект из detached в persistent. Данный метод предназначен для сохранения в БД объекта с заданным Id, чего не позволяют сделать persist() и merge(). Если объект с данным Id уже существует в БД, то поведение определяется согласно правилу из перечисления org.hibernate.ReplicationMode:
    - **ReplicationMode.IGNORE** — ничего не меняется в базе.
    - **ReplicationMode.OVERWRITE** — объект сохраняется в базу вместо существующего.
    - **ReplicationMode.LATEST_VERSION** — в базе сохраняется объект с последней версией.
    - **ReplicationMode.EXCEPTION** — генерирует исключение.
- **delete(Object)** - удаляет объект из БД, иными словами, преобразует persistent в transient. Object может быть в любом статусе, главное, чтобы был установлен Id.
- **save(Object)** - сохраняет объект в БД, генерируя новый Id, даже если он установлен. Object может быть в статусе transient или detached.
- **update(Object)** — обновляет объект в БД, преобразуя его в persistent (Object в статусе detached).
- **saveOrUpdate(Object)** - вызывает save() или update().
- **refresh(Object)** - обновляет detached-объект, выполнив select к БД, и преобразует его в persistent.
- **get(Object.class, id)** - получает из БД объект класса-сущности с определённым Id в статусе persistent.


#### Шаги для подключения hibernate (Maven)
1. Добавить зависимости (как минимум hibernate-core и JDBC драйвер базы данных) в pom.xml
2. Создать классы сущности(JPA Entity Class)
3. Создать файл конфигурации hibernate.cfg.xml
4. Создать hibernate util класс.
    
#### Создание Entity класса
Для того, чтобы пометить POJO класс Entity аннотацией он должен соответсвовать нескольким условиям:
+ иметь конструктор без параметров
+ необходимо назначить первичный ключ, т.е. пометить его аннотацией @Id
+ объявить геттеры и сеттеры
+ класс не должен быть final или иметь final методы

#### Пример hibernate.cfg.xml
```
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <!-- JDBC Database connection settings -->
        <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="connection.url">jdbc:mysql://localhost:3306/hibernate_db?useSSL=false</property>
        <property name="connection.username">root</property>
        <property name="connection.password">root</property>
        <!-- JDBC connection pool settings ... using built-in test pool -->
        <property name="connection.pool_size">1</property>
        <!-- Select our SQL dialect -->
        <property name="dialect">org.hibernate.dialect.MySQL5Dialect</property>
        <!-- Echo the SQL to stdout -->
        <property name="show_sql">true</property>
        <!-- Set the current session context -->
        <property name="current_session_context_class">thread</property>
        <!-- Drop and re-create the database schema on startup -->
        <property name="hbm2ddl.auto">create-drop</property>
        <!-- dbcp connection pool configuration -->
        <property name="hibernate.dbcp.initialSize">5</property>
        <property name="hibernate.dbcp.maxTotal">20</property>
        <property name="hibernate.dbcp.maxIdle">10</property>
        <property name="hibernate.dbcp.minIdle">5</property>
        <property name="hibernate.dbcp.maxWaitMillis">-1</property>
        <mapping class="net.javaguides.hibernate.entity.Student" />
    </session-factory>
</hibernate-configuration>
```
#### Hibernate utils
Создание utils класса подразумевает три этапа:
+ Создать объект класса **StandartServiceRegistry**
+ Создать объект класса **Metadata**
+ использовать их для создания **SessionFactory**

**ServiceRegistry** содержит службы, которые понадобятся Hibernate во время начальной загрузки и во время выполнения.
**HibernateUtil** - это вспомогательный класс загрузки hibernate SessionFactory. 
В большинстве приложений Hibernate экземпляр SessionFactory должен создаваться один раз во время инициализации приложения. Затем один экземпляр должен использоваться всем кодом в конкретном процессе, и любой сеанс должен создаваться с использованием этой единственной SessionFactory. SessionFactory потокобезопасен и может быть разделен; сессия является однопоточным объектом. 

### Транзакции
Транзакция — это совокупность операций над базой данных, которые вместе образуют логически целостную процедуру, и могут быть либо выполнены все вместе, либо не будет выполнена ни одна из них.
Транзакции являются одним из средств обеспечения согласованности базы данных. Они переводят БД из одного согласованного состояния в другое.

Транзакция может иметь два исхода: 
+ Изменение данных, произведенные в ходе ее выполнения, успешно зафиксированны в базе данных
+ транзакция отменяется, и отменяются все изменения, выполненные в ее рамках (rollback)

    Реализация транзакций в СУБД PostgreSQL основана на многоверсионной модели(Multiversion Concurensy Control). Каждый SQL-оператор видит так называемый snapshot, то есть согласованное остояние (версию) БД, которую она имела на определенный момент времени. Параллельные транзакции не наршуют согласованности данных этого snapshot'a. Когда параллельные транзакции изменяют одни и те же строки таблиц , тогда создаются отдельные версии этих строк, доступные соответсвующим транзакциям. Также MVCC никогда не блокируются операциями записи, и наоборот.

Согласно теории БД транзакции должны обладать следующими свойствами:
+ **Атомарность (atomicity)**. Это свойство означает, что либо транзакция будет зафиксирована в базе данных полностью, т. е. будут зафиксированы результаты выполнения всех ее операций, либо не будет зафиксирована ни одна операция транзакции.
+  **Согласованность (consistency)**. Это свойство предписывает, чтобы в результате успешного выполнения транзакции база данных была переведена из одного согласованного состояния в другое согласованное состояние.
+  **Изолированность (isolation).** Во время выполнения транзакции другие транзакции должны оказывать по возможности минимальное влияние на нее.
+  **Долговечность (durability).** После успешной фиксации транзакции пользователь должен быть уверен, что данные надежно сохранены в базе данных и впоследствии могут быть извлечены из нее, независимо от последующих возможных сбоев в работе системы.

При параллельном выполнении транзакций возможны следующие феномены:
+ **Потерянное обновление (lost update).** Когда разные транзакции одновременно изменяют одни и те же данные, то после фиксации изменений может оказаться, что одна транзакция перезаписала данные, обновленные и зафиксированные другой транзакцией.
+ **«Грязное» чтение (dirty read).** Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась. Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе.
+ **Неповторяющееся чтение (non-repeatable read).** При повторном чтении тех же самых данных в рамках одной транзакции оказывается, что другая транзакция успела изменить и зафиксировать эти данные. В результате тот же самый запрос выдает другой результат.
+ **Фантомное чтение (phantom read).** Транзакция повторно выбирает множество строк в соответствии с одним и тем же критерием. В интервале времени между выполнением этих выборок другая транзакция добавляет новые строки и успешно фиксирует изменения. В результате при выполнении повторной выборки в первой транзакции может быть получено другое множество строк.
+ **Аномалия сериализации (serialization anomaly).** Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одного из возможных вариантов упорядочения этих транзакций, если бы они выполнялись последовательно.

Сериализация двух транзакций при их параллельном выполнении означает, что полученный результат будет соответствовать одному из двух возможных вариантов упорядочения транзакций при их последовательном выполнении. При этом нельзя сказать точно, какой из вариантов будет реализован.
Если СУБД не сможет гарантировать успешную сериализацию группы параллельных транзакций, тогда некоторые из них могут быть завершены с ошибкой. Эти транзакции придется выполнить повторно.
Для конкретизации степени не зависимости параллельных транзакций вводится понятие уровня изоляции транзакций. Каждый уровень характеризуется перечнем тех феноменов, которые на данном уровне не допускаются.

Всего в стандарте SQL предусмотрено четыре уровня. Каждый более высокий уровень включает в себя все возможности предыдущего.
+ Read Uncommitted. Это самый низкий уровень изоляции. Согласно стандарту SQL на этом уровне допускается чтение «грязных» (незафиксированных) данных.
+ Read Uncommitted. Это самый низкий уровень изоляции. Согласно стандарту SQL на этом уровне допускается чтение «грязных» (незафиксированных) данных. Транзакция может видеть только те незафиксированные изменения данных, которые произведены в ходе выполнения ее самой.
+ Repeatable Read. Не допускается чтение «грязных» (незафиксированных) данных и неповторяющееся чтение.
+ Serializable. Не допускается ни один из феноменов, перечисленных выше, в том числе и аномалии сериализации.

#### Transactions в Hibernate
В hibernate есть Transaction interface, который определяет единицу работы. Он представляет из себя абстракцию более высокого уровня реализации транзакций JTA, JDBC.
Transaction входит в Session и её можно получить с помощью метода beginTransaction()
Методы Transaction interface:
- **void begin()**
- **void commit()**
- **void rollback()**
- **void setTimeout(int seconds)**
- **void isAlive()**
- **void registerSynchronization(Synchronization s)**
- **boolean wasCommited()**
- **boolean wasRolledBack()**

https://docs.jboss.org/hibernate/orm/3.2/api/org/hibernate/Transaction.html

### Cascade types

### Односторонние и двухсторонние отношения в Hibernate
Варианта всего 4:
- OneToOne - один к одному
- OneToMany - один ко многим
- ManyToOne - многие к одному
- ManyToMany - многие ко многим

Каждое из этих отношений может быть односторонним (unidirectional) или двусторонним (bidirectional).

#### Односторонние отношения

Односторонним называется отношение, владельцем которого является только одна из двух сторон. Отсюда и название. Следует заметить, что при этом вторая сторона об этом отношении ничего не знает. Hibernate будет считать владельцем отношения ту сущность, в которой будет поставлена аннотация отношения.

При этом владельцем отношения сделаем сторону контакта. При этом сущности будут выглядеть следующим образом.
```
@Entity
@Table(name = "contacts")
public class Contact {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column
    private String type;

    @Column
    private String data;
    
    // Конструктор по умолчанию, геттеры, сеттеры и т.д.
}

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column
    private String username;

    @OneToMany
    private List<Contact> contacts;

    // Конструктор по умолчанию, гетеры, сеттеры и т.д.
}
```
 Если запустить данный код и посмотреть на созданную Hibernate структуру таблиц, то мы столкнёмся с одной хорошо известной проблемой.

```
create table contacts (
    id bigint not null auto_increment,
    data varchar(255),
    type varchar(255),
    primary key (id)
) engine=InnoDB;

create table users (
    id bigint not null auto_increment,
    username varchar(128) not null,
    primary key (id)
) engine=InnoDB;

create table users_contacts (
    User_id bigint not null,
    contacts_id bigint not null
) engine=InnoDB;
```
Чтобы связать сущности Hibernate создал дополнительную таблицу связи (join table) с именем users_contacts, хотя сущности вполне можно было бы связать через ссылочное поле в таблице contacts.

Проблему можно легко решить добавив аннотацию JoinColumn к полю contacts.

```
 @OneToMany
 @JoinColumn(name = "user_id")
 private List<Contact> contacts;
```

При таких настройках связь будет проводиться при помощи колонки user_id в таблице contacts, а таблица связи создаваться не будет.

#### Двусторонние отношения

У двусторонних отношений помимо стороны - владельца (owning side) имеется ещё и противоположная сторона (inverse side). Т.е. обе стороны отношения обладают информацией о связи. Логично предположить, что из одностороннего отношения можно сделать двустороннее просто добавив поле и аннотацию в класс сущности противоположной стороны.
```
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column
    private String username;

    @ManyToMany
    private List<Role> roles;

    // Конструктор по умолчанию, гетеры, сеттеры и т.д.
}

@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column
    private String name;

    @ManyToMany
    private List<User> users;

    // Конструктор по умолчанию, гетеры, сеттеры и т.д.
}
```
 Помимо таблиц для пользователей и ролей Hibernate создаст две таблицы связи, хотя хватило бы и одной.
 
 ```
 create table roles_users (
    Role_id bigint not null,
    users_id bigint not null
) engine=InnoDB;

create table users_roles (
    User_id bigint not null,
    roles_id bigint not null
) engine=InnoDB;
```

Дело в том, что вместо одного двустороннего отношения были созданы два односторонних. Тоже самое произойдет и для отношения один ко многим. Чтобы Hibernate понял, что нужно создать именно двустороннее отношение нужно указать, какая из сторон является владельцем отношений, а какая является обратной стороной. Это делается при помощи атрибута **mappedBy**. Важно отметить, что указывается этот атрибут в аннотации, которая находится на противоположной стороне отношения.

```
    // значение атрибута mappedBy - имя поля связи в классе сущности-владельца отношений
    @ManyToMany(mappedBy = "roles")
    private List<User> users;
```

Следует отметить, что в отношении один ко многим стороной-владельцем может быть только сторона многих (many), поэтому атрибут mappedBy есть только в аннотации @OneToMany .
